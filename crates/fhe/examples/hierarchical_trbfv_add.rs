// Implementation of SECURE 2-level hierarchical threshold addition using the `fhe` and `mbfv` crate.
//
// This example demonstrates a TRULY SECURE 2-level hierarchical threshold BFV setup where:
// - Level 1 (Bottom): Individual party secrets within groups (NO group master secrets)
// - Level 2 (Top): MBFV aggregation from threshold parties (SECURE aggregation only)
// - Each group requires threshold participation for both keyshare generation AND decryption
// - ZERO secret reconstruction: only aggregation of individual MBFV shares
//
// SECURITY Model (CORRECTED):
// - Each party has individual secret key and generates individual MBFV keyshare/decryption share
// - Group-level MBFV keyshares generated by aggregating individual shares from threshold parties
// - Group-level decryption shares generated by aggregating individual shares from threshold parties
// - NO group master secrets, NO SSS reconstruction - only MBFV aggregation
// - Threshold parties from each group must participate, but NO secrets are ever reconstructed
//
// Communication Complexity:
// - Within groups: O(threshold) for collecting individual MBFV shares
// - Between groups: O(num_groups) for MBFV public key and decryption aggregation
// - Total: O(num_groups × threshold) - much simpler and more secure
//
// Example usage:
// - `--num_groups=3 --group_size=4 --threshold=3` creates 3 groups of 4 parties each with 3/4 threshold
// - `--num_groups=2 --group_size=5 --threshold=3` creates 2 groups of 5 parties each with 3/5 threshold
//
// Architecture:
// - Bottom layer: Individual party secrets (no sharing, no reconstruction)
// - Top layer: MBFV aggregation from threshold parties (secure additive aggregation only)
// - Secure: TRUE threshold cryptography with ZERO secret reconstruction

mod util;

use std::{env, error::Error, process::exit, sync::Arc};

use crate::util::timeit::{timeit, timeit_n};
use console::style;
use fhe::{
    bfv::{self, Ciphertext, Encoding, Plaintext, PublicKey, SecretKey},
    mbfv::{AggregateIter, CommonRandomPoly, PublicKeyShare},
    trbfv::TrBFVShare,
};
use fhe_traits::{FheEncoder, FheEncrypter};
use rand::distributions::Distribution;
use rand::distributions::Uniform;
use rand::rngs::OsRng;
use rand::thread_rng;

// Secure 2-level hierarchical party structure using pure MBFV aggregation
// Level 1: Individual party secrets (no sharing required)
// Level 2: MBFV aggregation from threshold parties
struct Party {
    secret_key: SecretKey,    // Individual party secret key (SECURE: never shared)
    pk_share: PublicKeyShare, // Individual MBFV public key share
}

fn print_notice_and_exit(error: Option<String>) {
    println!(
        "{} Addition with 2-level hierarchical threshold BFV",
        style("  overview:").magenta().bold()
    );
    println!(
        "{} add [-h] [--help] [--num_summed=<value>] [--num_groups=<value>] [--group_size=<value>] [--threshold=<value>]",
        style("     usage:").magenta().bold()
    );
    println!(
        "{} 2-level hierarchy: trBFV within groups, MBFV across groups",
        style("      note:").magenta().bold()
    );
    println!(
        "{} {} {} {} and {} must be at least 1, and threshold < group_size",
        style("constraints:").magenta().bold(),
        style("num_summed").blue(),
        style("num_groups").blue(),
        style("group_size").blue(),
        style("threshold").blue(),
    );
    if let Some(error) = error {
        println!("{} {}", style("     error:").red().bold(), error);
    }
    exit(0);
}

fn main() -> Result<(), Box<dyn Error>> {
    // Parameters
    let degree = 2048;
    let plaintext_modulus: u64 = 4096;
    let moduli = vec![0xffffee001, 0xffffc4001, 0x1ffffe0001];

    // Parse command line arguments
    let args: Vec<String> = env::args().skip(1).collect();

    if args.contains(&"-h".to_string()) || args.contains(&"--help".to_string()) {
        print_notice_and_exit(None)
    }

    let mut num_summed = 1;
    let mut num_groups = 2; // Default: 2 groups
    let mut group_size = 3; // Default: 3 parties per group
    let mut threshold = 2; // Default: 2/3 threshold within each group

    // Parse command line arguments
    for arg in &args {
        if arg.starts_with("--num_summed") {
            let a: Vec<&str> = arg.rsplit('=').collect();
            if a.len() != 2 || a[0].parse::<usize>().is_err() {
                print_notice_and_exit(Some("Invalid `--num_summed` argument".to_string()))
            } else {
                num_summed = a[0].parse::<usize>().unwrap();
            }
        } else if arg.starts_with("--num_groups") {
            let a: Vec<&str> = arg.rsplit('=').collect();
            if a.len() != 2 || a[0].parse::<usize>().is_err() {
                print_notice_and_exit(Some("Invalid `--num_groups` argument".to_string()))
            } else {
                num_groups = a[0].parse::<usize>().unwrap();
            }
        } else if arg.starts_with("--group_size") {
            let a: Vec<&str> = arg.rsplit('=').collect();
            if a.len() != 2 || a[0].parse::<usize>().is_err() {
                print_notice_and_exit(Some("Invalid `--group_size` argument".to_string()))
            } else {
                group_size = a[0].parse::<usize>().unwrap();
            }
        } else if arg.starts_with("--threshold") {
            let a: Vec<&str> = arg.rsplit('=').collect();
            if a.len() != 2 || a[0].parse::<usize>().is_err() {
                print_notice_and_exit(Some("Invalid `--threshold` argument".to_string()))
            } else {
                threshold = a[0].parse::<usize>().unwrap();
            }
        } else {
            print_notice_and_exit(Some(format!("Unrecognized argument: {arg}")))
        }
    }

    // Validate parameters
    if num_summed == 0 || num_groups == 0 || group_size == 0 || threshold == 0 {
        print_notice_and_exit(Some("All parameters must be nonzero".to_string()))
    }
    if threshold >= group_size {
        print_notice_and_exit(Some("Threshold must be less than group_size".to_string()))
    }

    // Calculate total number of parties and hierarchical threshold
    let total_parties = num_groups * group_size;
    let hierarchical_threshold = threshold * num_groups; // Total threshold for hierarchical decryption

    // Display hierarchy information
    println!("# Hierarchical trBFV Addition");
    println!("num_summed={}", num_summed);
    println!("num_groups={}", num_groups);
    println!("group_size={}", group_size);
    println!("threshold={}/{}", threshold, group_size);
    println!("total_parties={}", total_parties);
    println!("hierarchical_threshold={}", hierarchical_threshold);

    // Generate the BFV parameters structure
    let params = timeit!(
        "Parameters generation",
        bfv::BfvParametersBuilder::new()
            .set_degree(degree)
            .set_plaintext_modulus(plaintext_modulus)
            .set_moduli(&moduli)
            .build_arc()?
    );

    // Generate a common reference poly for public key generation
    let crp = CommonRandomPoly::new(&params, &mut thread_rng())?;

    // Create TrBFV instance for hierarchical threshold operations
    // Use total_parties and hierarchical_threshold for true hierarchical threshold cryptography
    let _trbfv = TrBFVShare::new(
        total_parties,          // Total number of parties across all groups
        hierarchical_threshold, // Total threshold requiring participation from all groups
        degree,
        plaintext_modulus,
        160,
        moduli.clone(),
        params.clone(),
    )?;

    // Generate hierarchical parties with SECURE individual secrets (no SSS sharing)
    // SECURE hierarchical approach: individual party secrets + MBFV aggregation only
    let all_parties: Vec<Party> = timeit!(
        "Generate hierarchical parties with individual secrets + SSS aggregation",
        {
            let mut parties = Vec::with_capacity(total_parties);

            // Process each group - each party has individual secret, generates individual MBFV share
            for group_id in 0..num_groups {
                let group_start = group_id * group_size;

                // Create parties in this group - each with individual secret key
                for party_local_id in 0..group_size {
                    let _party_idx = group_start + party_local_id;

                    // SECURE: Generate individual secret key for this party
                    let secret_key = SecretKey::random(&params, &mut OsRng);

                    // Generate individual MBFV public key share using this party's own secret
                    let pk_share =
                        PublicKeyShare::new(&secret_key, crp.clone(), &mut thread_rng())?;

                    parties.push(Party {
                        secret_key,
                        pk_share,
                    });
                }
            }

            parties
        }
    );

    // Phase 3: SECURE Hierarchical public key generation using MBFV aggregation only
    // Each group generates an MBFV keyshare by aggregating individual shares from threshold parties
    // These group-level MBFV keyshares are aggregated to form the final public key
    // ZERO secret reconstruction - only secure MBFV aggregation
    let final_pk = timeit!(
        "SECURE Hierarchical public key setup with pure MBFV aggregation",
        {
            let mut group_pk_shares = Vec::new();

            for group_id in 0..num_groups {
                let group_start = group_id * group_size;

                // Get individual MBFV public key shares from threshold parties in this group
                let mut threshold_individual_pk_shares = Vec::new();

                for party_offset in 0..threshold {
                    let party_idx = group_start + party_offset;
                    let party = &all_parties[party_idx];
                    threshold_individual_pk_shares.push(party.pk_share.clone());
                }

                // Generate group-level MBFV public key share using secure aggregation
                // SECURE: No secret reconstruction - only aggregation of individual MBFV shares
                let group_pk_share = PublicKeyShare::new_from_threshold_parties(
                    threshold_individual_pk_shares,
                    threshold,
                )?;

                group_pk_shares.push(group_pk_share);
            }

            // Aggregate group-level MBFV public key shares to create final public key
            let final_pk: PublicKey = group_pk_shares.into_iter().aggregate()?;
            final_pk
        }
    );

    // Unpack the returned tuple

    // Encrypted addition setup
    let dist = Uniform::new_inclusive(0, 1);
    let numbers: Vec<u64> = dist
        .sample_iter(&mut thread_rng())
        .take(num_summed)
        .collect();

    let mut numbers_encrypted = Vec::with_capacity(num_summed);
    let mut _i = 0;
    timeit_n!("Encrypting Numbers (per encryption)", num_summed as u32, {
        #[allow(unused_assignments)]
        let pt = Plaintext::try_encode(&[numbers[_i]], Encoding::poly(), &params)?;
        let ct = final_pk.try_encrypt(&pt, &mut thread_rng())?;
        numbers_encrypted.push(ct);
        _i += 1;
    });

    // Homomorphic addition
    let tally = timeit!("Number tallying", {
        let mut sum = Ciphertext::zero(&params);
        for ct in &numbers_encrypted {
            sum += ct;
        }
        Arc::new(sum)
    });

    // Hierarchical threshold decryption using SECURE MBFV aggregation only
    let final_result = timeit!("SECURE Hierarchical threshold decryption", {
        use fhe::mbfv::{AggregateIter, DecryptionShare};

        let mut group_decryption_shares = Vec::new();

        // Each group generates a group-level MBFV decryption share
        for group_id in 0..num_groups {
            let group_start = group_id * group_size;

            // Get individual MBFV decryption shares from threshold parties in this group
            let mut threshold_individual_decryption_shares = Vec::new();

            for party_offset in 0..threshold {
                let party_idx = group_start + party_offset;
                let party = &all_parties[party_idx];

                // Each party generates their individual MBFV decryption share
                let individual_decryption_share =
                    DecryptionShare::new(&party.secret_key, &tally, &mut thread_rng())?;

                threshold_individual_decryption_shares.push(individual_decryption_share);
            }

            // Generate group-level MBFV decryption share using secure aggregation
            // SECURE: No secret reconstruction - only aggregation of individual MBFV shares
            let group_decryption_share = DecryptionShare::new_from_threshold_parties(
                threshold_individual_decryption_shares,
                threshold,
            )?;

            group_decryption_shares.push(group_decryption_share);
        }

        // Aggregate group-level MBFV decryption shares to decrypt
        let plaintext: Plaintext = group_decryption_shares.into_iter().aggregate()?;

        // Decode the result
        use fhe_traits::FheDecoder;
        let result_vec = Vec::<u64>::try_decode(&plaintext, Encoding::poly())?;
        result_vec[0]
    });

    // Show summation result
    let expected_result: u64 = numbers.iter().sum();
    println!("Expected: {}, Got: {}", expected_result, final_result);

    if final_result != expected_result {
        println!("⚠️  Results don't match");
        println!("Numbers: {:?}", numbers);
        return Err("Assertion failed: results don't match".into());
    }

    println!("✅ Success!");
    Ok(())
}
